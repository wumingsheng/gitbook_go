# 07 | 数组和切片

![](https://static001.geekbang.org/resource/image/dd/1b/dd325dbcedf291bb9272695d5856981b.jpg)

数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。


我们其实可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。

也正因为如此，Go 语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；而 Go 语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。

* 引用类型：切片类型、字典类型、通道类型、函数类型
* 值类型： 数组类型、基础数据类型、结构体类型

如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。

- 我们通过调用内建函数len，得到数组和切片的长度。
- 通过调用内建函数cap，我们可以得到它们的容量。
- 数组的容量永远等于其长度，都是不可变的
- 切片的容量却不是这样，并且它的变化是有规律可寻的

## 怎样正确估算切片的长度和容量？


```go
package main

import "fmt"

func main() {

	s1 := make([]int, 5)//不指明容量，容量和长度相同

	fmt.Printf("%d, %d, %s\n", len(s1), cap(s1), s1)  // 5 , 5 , []

	s2 := make([]int, 5, 8)//也可以指明容量

	fmt.Printf("%d, %d, %s", len(s2), cap(s2), s2)  //5, 8 ,[]

}

```

我用内建函数make声明了一个[]int类型的变量s1。我传给make函数的第二个参数是5，从而指明了该切片的长度。
我用几乎同样的方式声明了切片s2，只不过多传入了一个参数8以指明该切片的容量。

解析一下这道题。s1的容量为什么是5呢？因为我在声明s1的时候把它的长度设置成了5。当我们用make函数初始化切片时，如果不指明其容量，那么它就会和长度一致。如果在初始化时指明了容量，那么切片的实际容量也就是它了。这也正是s2的容量是8的原因。

> 容量必须大于长度，长度只是容量的一个子集，容量是切片初始化时被创建的底层数组的长度


现在你需要跟着我一起想象：有一个窗口，你可以通过这个窗口看到一个数组，但是不一定能看到该数组中的所有元素，有时候只能看到连续的一部分元素。



```go
package main

import "fmt"

func main() {

	s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
	s4 := s3[3:6]

	fmt.Printf("%d, %d \n", len(s3), cap(s3))      //切片s3中有 8 个元素，分别是从1到8的整数。s3的长度和容量都是8
	fmt.Printf("%d, %d, %s", len(s4), cap(s4), s4) //由于s4是通过在s3上施加切片操作得来的，所以s3的底层数组就是s4的底层数组。

}
```

由于s4是通过在s3上施加切片操作得来的，所以s3的底层数组就是s4的底层数组。

又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。

所以，s4的容量就是其底层数组的长度8, 减去上述切片表达式中的那个起始索引3，即5。

注意，切片代表的窗口是无法向左扩展的。也就是说，我们永远无法透过s4看到s3中最左边的那 3 个元素。











